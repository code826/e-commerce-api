//
//rate a product
// we will see how to use $push and make update on nesting object

{
    _id:'326478362496350635',
    name:'product_1',
    describtion:'',
    rating: [
        {
            userId:1
            rating:5
        },
        {
            userId:2,
            rating:4
        }
    ]
}
// ,1,5
//rating 
 //productId,userId,rating


// cart controller

// 
 {
    userId:
    productId:
    qty:
 }

 //
 {
    userId:1,
    productId:2
    qty:5+7
 }

  {
    userId:2,
    productId:2
    qty:5
 }
//case what happen if same userId but different productId 
  --> two different document will be created

// case what happen if user and product both are same
    // we will not create new entry just update the qty increment

// model
// get
// delete
// update
// insert

// update -->
// objectId


const { MongoClient } = require('mongodb');

// Connection URI
const uri = 'mongodb://localhost:27017';

// Create a new MongoClient
const client = new MongoClient(uri);

async function runTransaction() {
    const session = client.startSession();

    try {
        // Start transaction
        session.startTransaction();

        // Example: Access the collections
        const usersCollection = client.db('mydb').collection('users');
        const ordersCollection = client.db('mydb').collection('orders');

        // Insert operations (example)
        await usersCollection.insertOne({ name: 'Vikas', age: 30 }, { session });
        await ordersCollection.insertOne({ product: 'Laptop', price: 1500 }, { session });

        // Commit the transaction
        await session.commitTransaction();
        console.log('Transaction committed successfully!');
    } catch (error) {
        console.error('Transaction aborted due to an error:', error);
        await session.abortTransaction(); // Roll back changes
    } finally {
        session.endSession();
    }
}

client.connect()
    .then(runTransaction)
    .catch(console.error)
    .finally(() => client.close());


In MongoDB, the populate method is typically used in Mongoose to handle references between collections, creating relationships similar to SQL's foreign keys. However, populate itself doesn't enforce any restrictions like preventing deletion of a referenced document (as SQL would with foreign key constraints). If you delete a referenced document in MongoDB, the relationship will break, but it wonâ€™t stop you from performing the delete.

To mimic SQL-like behavior where a referenced document can't be deleted while it's in use, you would have to handle this manually. One common approach is to:

Use Mongoose Middleware (pre or post hooks): For example, you could add a pre('remove') hook to check whether a document is being referenced by any other document before allowing the delete operation.

Custom Logic in Your Code: Before performing a delete operation, you can check whether the document is referenced by querying other collections.

Here's a basic idea using a pre hook to check references before deletion:

javascript
Copy code
// Assuming a Post and User model where a post references a user
PostSchema.pre('remove', async function (next) {
  const user = await User.findById(this.user);  // Check reference
  if (user) {
    // Prevent delete if the user is still associated with this post
    return next(new Error('This post is referenced by a user.'));
  }
  next();
});
In this way, you can implement custom logic similar to SQL constraints but MongoDB doesn't enforce it out-of-the-box with populate.


